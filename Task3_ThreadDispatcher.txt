	Задача №3 - dispatcher.Dispatcher.ThreadDispatcher - ООП

    Цель данного упражнения познакомить студента с особенностями многопоточного программирования в Java\С#,
    а также сконструировать модуль для дальнейшей работы. В рамках выполнения упражнения необходимо учесть
    механизмы синхронизации и обспечение монопольного доступа. Далее задача формулируется для Java.


    1. Необходимо написать класс-thread-safe-singleton dispatcher.Dispatcher.ThreadDispatcher.
    Данный класс представляет собой диспетчер потоков, который 	способен ставить
    задачи на параллельное выполнение. Класс содержит следующий метод:x

		public void Add(Threaded.Threaded task) - данный метод запускает на выполнение задачу.

	Threaded.Threaded - абстрактный базовый класс, реализующий интерфейс Runnable.
	Runnable - интерфейс Java, позволяющий 	выполнять код многопоточно.
	Соотвественно, чтобы создать определенную 	задачу, необходимо отнаследоваться от
	Threaded.Threaded и переопределить метод run:

	class SleepWorker extends Threaded.Threaded
	{
		public void run()
		{
			Thread.sleep(10000);
		}
	}

		Класс SleepWorker представляет собой пример задачи параллельного выполнения.
		В данном случае в отдельном потоке будет выполено тело метода run() - поток заснет на 10 секунд.
		Затем завершится. Таким образом, порождая наследников Threaded.Threaded и переопределяя метод
		run() возможно создание произвольных задач для параллельного выполнения.


    2. При создании объекта dispatcher.Dispatcher.ThreadDispatcher необходимо в конструкторе вызвать метод

		void Add(Threaded.Threaded task) - где аргументом task должен быть экземпляр класс Dispatcher.ThreadMonitor, являющийся наследником Threaded.Threaded.
		То есть при создании диспетчера потоков по умолчанию сразу же создается фоновый поток.

	Dispatcher.ThreadMonitor - класс, реализующий функциональность монитора потоков. Необходимо с его помощью в методе run()
	реализовать вывод в файл списка запущенных потоков и их идентификаторов. Соотвественно, как только поток
	завершился, список монитора потоков должен обновиться, и данный поток должен исчезнуть.
	При запуске потока - поток 	должен добавиться в вывод.
	Подобное поведение можно наблюдать в диспетчере задач в Windows. Монитор потоков работает столько,
	сколько существует singleton dispatcher.Dispatcher.ThreadDispatcher. Не может отключаться или ставиться на паузу. Монитор
	всегда показывает актуальное состояние диспетчера потоков.

	ВАЖНО: необходимо реализовать именно отображение в реальном времени списка запущенных потоков, а не бесконечный
	вывод актуального состояния в файл.

      *. Реализовать вызов callback-функции при завершении метода run(). То есть необходимо сделать механизм оповещения от
      потока к диспетчеру о том, что поток готовится к завршению.


